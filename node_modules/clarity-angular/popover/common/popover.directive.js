import { Directive, EventEmitter, Input, Output, TemplateRef, ViewContainerRef } from "@angular/core";
import { Popover } from "./popover";
var openCount = 0;
var waiting = []; // pending create functions
var PopoverDirective = (function () {
    function PopoverDirective(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.popoverOptions = {};
        this.clrPopoverChange = new EventEmitter(false);
    }
    Object.defineProperty(PopoverDirective.prototype, "clrPopover", {
        set: function (open) {
            var _this = this;
            if (open) {
                if (this.popoverOptions.allowMultipleOpen) {
                    this.createPopover();
                }
                else {
                    if (openCount === 0) {
                        this.createPopover();
                    }
                    else {
                        waiting.push(function () {
                            _this.createPopover();
                        });
                    }
                }
            }
            else {
                this.viewContainer.clear();
                this.destroyPopover();
                if (!this.popoverOptions.allowMultipleOpen) {
                    if (waiting.length > 0) {
                        var createPopoverFn = waiting.shift();
                        createPopoverFn();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    PopoverDirective.prototype.createPopover = function () {
        var _this = this;
        var embeddedViewRef = this.viewContainer.createEmbeddedView(this.templateRef);
        //TODO: Not sure of the risks associated with using this. Find an alternative.
        //Needed for find the correct height and width of dynamically created views
        //inside of the popover. For Eg: Button Groups
        embeddedViewRef.detectChanges();
        // filter out other nodes in the view ref so we are only left with element nodes
        var elementNodes = embeddedViewRef.rootNodes.filter(function (node) {
            return node.nodeType === 1;
        });
        // we take the first element node in the embedded view; usually there should only be one anyways
        this._popoverInstance = new Popover(elementNodes[0]);
        this._subscription = this._popoverInstance.anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions).subscribe(function () {
            _this.clrPopoverChange.emit(false);
        });
        openCount++;
    };
    PopoverDirective.prototype.destroyPopover = function () {
        if (this._popoverInstance) {
            this._subscription.unsubscribe();
            this._popoverInstance.destroy();
            delete this._popoverInstance;
            openCount--;
        }
    };
    PopoverDirective.prototype.ngOnDestroy = function () {
        this.destroyPopover();
    };
    return PopoverDirective;
}());
export { PopoverDirective };
PopoverDirective.decorators = [
    { type: Directive, args: [{ selector: "[clrPopover]" },] },
];
/** @nocollapse */
PopoverDirective.ctorParameters = function () { return [
    { type: TemplateRef, },
    { type: ViewContainerRef, },
]; };
PopoverDirective.propDecorators = {
    'anchorElem': [{ type: Input, args: ["clrPopoverAnchor",] },],
    'anchorPoint': [{ type: Input, args: ["clrPopoverAnchorPoint",] },],
    'popoverPoint': [{ type: Input, args: ["clrPopoverPopoverPoint",] },],
    'popoverOptions': [{ type: Input, args: ["clrPopoverOptions",] },],
    'clrPopoverChange': [{ type: Output, args: ["clrPopoverChange",] },],
    'clrPopover': [{ type: Input },],
};
//# sourceMappingURL=popover.directive.js.map